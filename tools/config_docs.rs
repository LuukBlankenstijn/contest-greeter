use std::collections::BTreeMap;

use anyhow::Result;
use lightdm_contest_rs_greeter::conf::Conf;
use schemars::{Map, schema::*, schema_for};
use serde_json::Value;

const ROOT_ORDER: &[&str] = &[
    "log_level",
    "chain",
    "background_source",
    "countdown_end_time",
    "countdown_from",
    "countdown_end_login",
    "countdown_label_color",
    "session",
    "username",
    "password",
    "interval",
    "url",
];

struct Row {
    key: String,
    ty: String,
    default_val: String,
    description: String,
    required: bool,
}

fn main() -> Result<()> {
    let schema = schema_for!(Conf);
    let defaults = serde_json::to_value(Conf::default())?;

    let mut rows = Vec::new();
    collect_properties(
        "",
        &Schema::Object(schema.schema.clone()),
        &schema.definitions,
        &defaults,
        true,
        Some(ROOT_ORDER),
        &mut rows,
    );

    println!("> [!NOTE]");
    println!("> This file is generated by AI generated code, be aware for mistakes.");
    println!();
    println!("# Configuration\n");
    println!("| Key | Type | Required | Default | Description |");
    println!("| --- | --- | --- | --- | --- |");
    for row in rows {
        println!(
            "| {} | {} | {} | {} | {} |",
            escape(&row.key),
            escape(&row.ty),
            if row.required { "yes" } else { "no" },
            escape(&row.default_val),
            escape(&row.description)
        );
    }

    Ok(())
}

fn collect_properties(
    prefix: &str,
    schema: &Schema,
    definitions: &Map<String, Schema>,
    defaults: &Value,
    required_here: bool,
    order: Option<&[&str]>,
    rows: &mut Vec<Row>,
) {
    let Some(obj) = as_object(schema, definitions) else {
        return;
    };
    if let Some(obj_validation) = &obj.object {
        let required_fields = obj_validation.required.iter().collect::<Vec<_>>();
        for (name, prop_schema) in ordered_props(&obj_validation.properties, order) {
            let full_key = if prefix.is_empty() {
                name.to_string()
            } else {
                format!("{}.{}", prefix, name)
            };

            let is_required = required_here && required_fields.iter().any(|r| r.as_str() == name);

            if is_object(prop_schema, definitions) {
                collect_properties(
                    &full_key,
                    prop_schema,
                    definitions,
                    defaults,
                    is_required,
                    None,
                    rows,
                );
            } else {
                let description = description(prop_schema, definitions);
                let ty = schema_type(prop_schema, definitions);
                let default_val =
                    default_for_path(defaults, &full_key).unwrap_or_else(|| "-".into());
                rows.push(Row {
                    key: full_key,
                    ty,
                    default_val,
                    description,
                    required: is_required,
                });
            }
        }
    }
}

fn ordered_props<'a>(
    props: &'a BTreeMap<String, Schema>,
    preferred_order: Option<&'a [&'a str]>,
) -> Vec<(&'a str, &'a Schema)> {
    let mut entries: Vec<(&str, &Schema)> = Vec::new();

    if let Some(order) = preferred_order {
        for name in order {
            if let Some(schema) = props.get(*name) {
                entries.push((name, schema));
            }
        }
    }

    for (name, schema) in props {
        if preferred_order
            .map(|order| order.contains(&name.as_str()))
            .unwrap_or(false)
        {
            continue;
        }
        entries.push((name.as_str(), schema));
    }

    entries
}

fn as_object<'a>(
    schema: &'a Schema,
    definitions: &'a Map<String, Schema>,
) -> Option<&'a SchemaObject> {
    match schema {
        Schema::Object(obj) => {
            if let Some(reference) = &obj.reference {
                let name = reference.rsplit('/').next()?;
                let referenced = definitions.get(name)?;
                as_object(referenced, definitions)
            } else {
                Some(obj)
            }
        }
        Schema::Bool(_) => None,
    }
}

fn description(schema: &Schema, definitions: &Map<String, Schema>) -> String {
    as_object(schema, definitions)
        .and_then(|obj| obj.metadata.as_ref())
        .and_then(|meta| meta.description.clone())
        .unwrap_or_default()
}

fn schema_type(schema: &Schema, definitions: &Map<String, Schema>) -> String {
    let obj = match as_object(schema, definitions) {
        Some(o) => o,
        None => return "unknown".into(),
    };

    #[allow(clippy::collapsible_if)]
    if let Some(subschemas) = &obj.subschemas {
        if let Some(any) = &subschemas.any_of {
            return join_types(any.iter().map(|s| schema_type(s, definitions)).collect());
        }
    }

    match &obj.instance_type {
        Some(SingleOrVec::Single(t)) => type_name(t),
        Some(SingleOrVec::Vec(list)) => join_types(list.iter().map(type_name).collect()),
        None => "object".into(),
    }
}

fn type_name(t: &InstanceType) -> String {
    match t {
        InstanceType::Null => "null".into(),
        InstanceType::Boolean => "bool".into(),
        InstanceType::Object => "object".into(),
        InstanceType::Array => "array".into(),
        InstanceType::Number => "number".into(),
        InstanceType::String => "string".into(),
        InstanceType::Integer => "integer".into(),
    }
}

fn default_for_path(defaults: &Value, path: &str) -> Option<String> {
    let mut current = defaults;
    for part in path.split('.') {
        current = current.get(part)?;
    }

    Some(match current {
        Value::Null => "-".into(),
        Value::Bool(b) => b.to_string(),
        Value::Number(n) => n.to_string(),
        Value::String(s) => format!("`{}`", s),
        Value::Array(_) | Value::Object(_) => "...".into(),
    })
}

fn join_types(mut types: Vec<String>) -> String {
    let nullable = types.iter().any(|t| t == "null");
    types.retain(|t| t != "null");
    let base = if types.is_empty() {
        "unknown".into()
    } else {
        types.join(" | ")
    };
    if nullable { format!("{base}?") } else { base }
}

fn escape(cell: &str) -> String {
    cell.replace('|', "\\|")
}

fn is_object(schema: &Schema, definitions: &Map<String, Schema>) -> bool {
    match as_object(schema, definitions) {
        Some(obj) => {
            matches!(obj.instance_type, Some(SingleOrVec::Single(ref t)) if matches!(**t, InstanceType::Object))
        }
        None => false,
    }
}
